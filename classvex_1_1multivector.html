<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>VexCL: vex::multivector&lt; T, N &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VexCL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevex.html">vex</a></li><li class="navelem"><a class="el" href="classvex_1_1multivector.html">multivector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">vex::multivector&lt; T, N &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Container for several vex::vectors.  
 <a href="classvex_1_1multivector.html#details">More...</a></p>

<p><code>#include &lt;vector.hpp&gt;</code></p>

<p><a href="classvex_1_1multivector-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1multivector_1_1const__element.html">const_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy class.  <a href="classvex_1_1multivector_1_1const__element.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1multivector_1_1element.html">element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy class.  <a href="classvex_1_1multivector_1_1element.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a64543203c0ebffee6614b82bdc61d4a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64543203c0ebffee6614b82bdc61d4a0"></a>
typedef <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>subtype</b></td></tr>
<tr class="memitem:a96e5a4217562ba9973c939817c50f12f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96e5a4217562ba9973c939817c50f12f"></a>
typedef std::array&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="memitem:ac6b9030e012bcccece6a317e1a6416fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6b9030e012bcccece6a317e1a6416fc"></a>
typedef iterator_type<br class="typebreak"/>
&lt; <a class="el" href="classvex_1_1multivector.html">multivector</a>, <a class="el" href="classvex_1_1multivector_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="memitem:aa78125fb76b8c9779052799b5846cfe4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa78125fb76b8c9779052799b5846cfe4"></a>
typedef iterator_type&lt; const <br class="typebreak"/>
<a class="el" href="classvex_1_1multivector.html">multivector</a>, <a class="el" href="classvex_1_1multivector_1_1const__element.html">const_element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a35b628677f6a82028795f03f709119e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1multivector.html#a35b628677f6a82028795f03f709119e2">multivector</a> (const std::vector&lt; cl::CommandQueue &gt; &amp;queue, const std::vector&lt; T &gt; &amp;host, cl_mem_flags flags=CL_MEM_READ_WRITE)</td></tr>
<tr class="memdesc:a35b628677f6a82028795f03f709119e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a35b628677f6a82028795f03f709119e2"></a><br/></td></tr>
<tr class="memitem:a7782bf8affd6ecad7af7a9bb73c6445d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1multivector.html#a7782bf8affd6ecad7af7a9bb73c6445d">multivector</a> (const std::vector&lt; cl::CommandQueue &gt; &amp;queue, size_t <a class="el" href="classvex_1_1multivector.html#ad3c7abe7faa85d0653cc001baaffbc8b">size</a>, const T *host=0, cl_mem_flags flags=CL_MEM_READ_WRITE)</td></tr>
<tr class="memdesc:a7782bf8affd6ecad7af7a9bb73c6445d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a7782bf8affd6ecad7af7a9bb73c6445d"></a><br/></td></tr>
<tr class="memitem:ae1de77d9ded0b34dc0716b3dc7c4a5d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1de77d9ded0b34dc0716b3dc7c4a5d3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1multivector.html#ae1de77d9ded0b34dc0716b3dc7c4a5d3">resize</a> (const std::vector&lt; cl::CommandQueue &gt; &amp;queue, size_t <a class="el" href="classvex_1_1multivector.html#ad3c7abe7faa85d0653cc001baaffbc8b">size</a>)</td></tr>
<tr class="memdesc:ae1de77d9ded0b34dc0716b3dc7c4a5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize multivector. <br/></td></tr>
<tr class="memitem:ad3c7abe7faa85d0653cc001baaffbc8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3c7abe7faa85d0653cc001baaffbc8b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1multivector.html#ad3c7abe7faa85d0653cc001baaffbc8b">size</a> () const </td></tr>
<tr class="memdesc:ad3c7abe7faa85d0653cc001baaffbc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size of a multivector (equals size of individual components). <br/></td></tr>
<tr class="memitem:a21a4fc199835a44e94000bbbf2e7ac18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21a4fc199835a44e94000bbbf2e7ac18"></a>
const <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1multivector.html#a21a4fc199835a44e94000bbbf2e7ac18">operator()</a> (uint i) const </td></tr>
<tr class="memdesc:a21a4fc199835a44e94000bbbf2e7ac18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns multivector component. <br/></td></tr>
<tr class="memitem:a44fcadfe340374d57e8d58eafbf78262"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44fcadfe340374d57e8d58eafbf78262"></a>
<a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1multivector.html#a44fcadfe340374d57e8d58eafbf78262">operator()</a> (uint i)</td></tr>
<tr class="memdesc:a44fcadfe340374d57e8d58eafbf78262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns multivector component. <br/></td></tr>
<tr class="memitem:a29f7eebb57e4df796b23595476ce7592"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29f7eebb57e4df796b23595476ce7592"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1multivector.html#a29f7eebb57e4df796b23595476ce7592">begin</a> () const </td></tr>
<tr class="memdesc:a29f7eebb57e4df796b23595476ce7592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator to beginning. <br/></td></tr>
<tr class="memitem:a7e41db7a8d4de021d801300e2995873e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e41db7a8d4de021d801300e2995873e"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1multivector.html#a7e41db7a8d4de021d801300e2995873e">begin</a> ()</td></tr>
<tr class="memdesc:a7e41db7a8d4de021d801300e2995873e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to beginning. <br/></td></tr>
<tr class="memitem:a78ee0ea4e3f62ae29cc849b31f81b903"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78ee0ea4e3f62ae29cc849b31f81b903"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1multivector.html#a78ee0ea4e3f62ae29cc849b31f81b903">end</a> () const </td></tr>
<tr class="memdesc:a78ee0ea4e3f62ae29cc849b31f81b903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator to end. <br/></td></tr>
<tr class="memitem:af922c212240609ff4ce10611985258e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af922c212240609ff4ce10611985258e2"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1multivector.html#af922c212240609ff4ce10611985258e2">end</a> ()</td></tr>
<tr class="memdesc:af922c212240609ff4ce10611985258e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to end. <br/></td></tr>
<tr class="memitem:a2ffbde83b873944936f6ea7f6c9ec342"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ffbde83b873944936f6ea7f6c9ec342"></a>
<a class="el" href="classvex_1_1multivector_1_1const__element.html">const_element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1multivector.html#a2ffbde83b873944936f6ea7f6c9ec342">operator[]</a> (size_t i) const </td></tr>
<tr class="memdesc:a2ffbde83b873944936f6ea7f6c9ec342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns elements of all vectors, packed in std::array. <br/></td></tr>
<tr class="memitem:a0fe4e1dacc01d8c972dfe81ec4a02186"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fe4e1dacc01d8c972dfe81ec4a02186"></a>
<a class="el" href="classvex_1_1multivector_1_1element.html">element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1multivector.html#a0fe4e1dacc01d8c972dfe81ec4a02186">operator[]</a> (size_t i)</td></tr>
<tr class="memdesc:a0fe4e1dacc01d8c972dfe81ec4a02186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns elements of all vectors to a std::array value. <br/></td></tr>
<tr class="memitem:a5d49d9214864a651f59890346e7818fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d49d9214864a651f59890346e7818fa"></a>
const std::vector<br class="typebreak"/>
&lt; cl::CommandQueue &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1multivector.html#a5d49d9214864a651f59890346e7818fa">queue_list</a> () const </td></tr>
<tr class="memdesc:a5d49d9214864a651f59890346e7818fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reference to multivector's queue list. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Expression assignments.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>All operations are delegated to components of the multivector. </p>
</div></td></tr>
<tr class="memitem:af64e991003e0b21a18655bec82d45029"><td class="memTemplParams" colspan="2"><a class="anchor" id="af64e991003e0b21a18655bec82d45029"></a>
template&lt;class Expr &gt; </td></tr>
<tr class="memitem:af64e991003e0b21a18655bec82d45029"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; compatible_multiex<br class="typebreak"/>
&lt; <a class="el" href="classvex_1_1multivector.html">multivector</a>, Expr &gt;::value, <br class="typebreak"/>
const <a class="el" href="classvex_1_1multivector.html">multivector</a> &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const Expr &amp;expr)</td></tr>
<tr class="memitem:a978816ec67ac42fcf834405ccdbd6fdb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a978816ec67ac42fcf834405ccdbd6fdb"></a>
template&lt;class Expr &gt; </td></tr>
<tr class="memitem:a978816ec67ac42fcf834405ccdbd6fdb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1multivector.html">multivector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const Expr &amp;expr)</td></tr>
<tr class="memitem:abfebca2f7f5852dda102c030e1bb3394"><td class="memTemplParams" colspan="2"><a class="anchor" id="abfebca2f7f5852dda102c030e1bb3394"></a>
template&lt;class Expr &gt; </td></tr>
<tr class="memitem:abfebca2f7f5852dda102c030e1bb3394"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1multivector.html">multivector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const Expr &amp;expr)</td></tr>
<tr class="memitem:a3ba6b3193699d1a55d2fa2240ecab7ee"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3ba6b3193699d1a55d2fa2240ecab7ee"></a>
template&lt;class Expr &gt; </td></tr>
<tr class="memitem:a3ba6b3193699d1a55d2fa2240ecab7ee"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1multivector.html">multivector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (const Expr &amp;expr)</td></tr>
<tr class="memitem:a429b1ddfbc96eb4413b391ba4b46678e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a429b1ddfbc96eb4413b391ba4b46678e"></a>
template&lt;class Expr &gt; </td></tr>
<tr class="memitem:a429b1ddfbc96eb4413b391ba4b46678e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1multivector.html">multivector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const Expr &amp;expr)</td></tr>
<tr class="memitem:aa51d9acdd18ebf275be8bf977ff1b930"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa51d9acdd18ebf275be8bf977ff1b930"></a>
template&lt;typename column_t &gt; </td></tr>
<tr class="memitem:aa51d9acdd18ebf275be8bf977ff1b930"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1multivector.html">multivector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const MultiSpMV&lt; T, column_t, N &gt; &amp;spmv)</td></tr>
<tr class="memitem:a4d1a4d2931fecec13c1bbf03426ec91d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d1a4d2931fecec13c1bbf03426ec91d"></a>
template&lt;typename column_t &gt; </td></tr>
<tr class="memitem:a4d1a4d2931fecec13c1bbf03426ec91d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1multivector.html">multivector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const MultiSpMV&lt; T, column_t, N &gt; &amp;spmv)</td></tr>
<tr class="memitem:a3608fff036148a6e3653ddbf8c023e63"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3608fff036148a6e3653ddbf8c023e63"></a>
template&lt;typename column_t &gt; </td></tr>
<tr class="memitem:a3608fff036148a6e3653ddbf8c023e63"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1multivector.html">multivector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const MultiSpMV&lt; T, column_t, N &gt; &amp;spmv)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ad7ad0f1b697f68f89b7419b7b1244b53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7ad0f1b697f68f89b7419b7b1244b53"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_multiex</b> = true</td></tr>
<tr class="memitem:a3de42299e65b63517faff18ad04ec94b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3de42299e65b63517faff18ad04ec94b"></a>
static const uint&#160;</td><td class="memItemRight" valign="bottom"><b>dim</b> = N</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, uint N&gt;<br/>
class vex::multivector&lt; T, N &gt;</h3>

<p>Container for several vex::vectors. </p>
<p>This class allows to synchronously operate on several vex::vectors of the same type and size. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a35b628677f6a82028795f03f709119e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvex_1_1multivector.html">vex::multivector</a>&lt; T, N &gt;::<a class="el" href="classvex_1_1multivector.html">multivector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; cl::CommandQueue &gt; &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem_flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>CL_MEM_READ_WRITE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>If host pointer is not NULL, it is copied to the underlying vector components of the multivector. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>queue list to be shared between all components. </td></tr>
    <tr><td class="paramname">host</td><td>Host vector that holds data to be copied to the components. Size of host vector should be divisible by N. Components of the created multivector will have size equal to host.size() / N. The data will be partitioned equally between all components. </td></tr>
    <tr><td class="paramname">flags</td><td>cl::Buffer creation flags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7782bf8affd6ecad7af7a9bb73c6445d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvex_1_1multivector.html">vex::multivector</a>&lt; T, N &gt;::<a class="el" href="classvex_1_1multivector.html">multivector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; cl::CommandQueue &gt; &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>host</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem_flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>CL_MEM_READ_WRITE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>If host pointer is not NULL, it is copied to the underlying vector components of the multivector. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>queue list to be shared between all components. </td></tr>
    <tr><td class="paramname">size</td><td>Size of each component. </td></tr>
    <tr><td class="paramname">host</td><td>Pointer to host buffer that holds data to be copied to the components. Size of the buffer should be equal to N * size. The data will be partitioned equally between all components. </td></tr>
    <tr><td class="paramname">flags</td><td>cl::Buffer creation flags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="vector_8hpp.html">vector.hpp</a></li>
<li><a class="el" href="spmat_8hpp.html">spmat.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1
</small></address>
</body>
</html>
