<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>VexCL: VexCL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VexCL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">VexCL </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>VexCL is vector expression template library for OpenCL. It has been created for ease of C++ based OpenCL development. Multi-device (and multi-platform) computations are supported. The source code is available at <a href="https://github.com/ddemidov/vexcl">https://github.com/ddemidov/vexcl</a>.</p>
<h1><a class="anchor" id="devlist"></a>
Selection of compute devices</h1>
<p>You can select any number of available compute devices, which satisfy provided filters. Filter is a functor returning bool and acting on a cl::Device parameter. Several standard filters are provided, such as device type or name filter, double precision support etc. Filters can be combined with logical operators. In the example below all devices with names matching "Radeon" and supporting double precision are selected: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vexcl_8hpp.html" title="Vector expression template library for OpenCL.">vexcl/vexcl.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>vex;</div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="classvex_1_1Context.html" title="VexCL context holder.">vex::Context</a> ctx(<a class="code" href="structvex_1_1Filter_1_1Name.html" title="Selects devices whose names match given value.">Filter::Name</a>(<span class="stringliteral">&quot;Radeon&quot;</span>) &amp;&amp; Filter::DoublePrecision);</div>
<div class="line">    std::cout &lt;&lt; ctx &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="el" href="classvex_1_1Context.html" title="VexCL context holder.">vex::Context</a> object holds list of initialized OpenCL contexts and command queues for each filtered device. If you just need list of available devices without creating contexts and queues on them, then look for <a class="el" href="namespacevex.html#a0571bb5e0afbc53f844665652a204b0a" title="Select devices by given criteria.">device_list()</a> function in documenation.</p>
<h1><a class="anchor" id="vector"></a>
Memory allocation and vector arithmetic</h1>
<p>Once you got queue list, you can allocate OpenCL buffers on the associated devices. <a class="el" href="classvex_1_1vector.html">vex::vector</a> constructor accepts std::vector of cl::CommandQueue. The contents of the created vector will be partitioned between each queue (presumably, each of the provided queues is linked with separate device). Size of each partition will be proportional to relative device bandwidth unless macro VEXCL_DUMB_PARTITIONING is defined, in which case equal partitioning scheme will be applied. Device bandwidth is measured first time it is requested by launch of small test kernel.</p>
<p>Multi-platform computation is supported (that is, you can spread your vectors across devices by different vendors), but should be used with caution: all computations will be performed with the speed of the slowest device selected.</p>
<p>In the example below host vector is allocated and initialized, then copied to all GPU devices found in the system. A couple of empty device vectors are allocated as well: </p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> n = 1 &lt;&lt; 20;</div>
<div class="line">std::vector&lt;double&gt; x(n);</div>
<div class="line">std::generate(x.<a class="code" href="classvex_1_1vector.html#ad15856f00b1c4b80726e6f908260ef57" title="Const iterator to beginning.">begin</a>(), x.<a class="code" href="classvex_1_1vector.html#a5169d2645c884403fa690d45c77552fa" title="Const iterator to end.">end</a>(), [](){ <span class="keywordflow">return</span> (<span class="keywordtype">double</span>)rand() / RAND_MAX; });</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvex_1_1Context.html" title="VexCL context holder.">vex::Context</a> ctx(Filter::Type(CL_DEVICE_TYPE_GPU));</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvex_1_1vector.html">vex::vector&lt;double&gt;</a> X(ctx.queue(), x);</div>
<div class="line"><a class="code" href="classvex_1_1vector.html">vex::vector&lt;double&gt;</a> Y(ctx.queue(), n);</div>
<div class="line"><a class="code" href="classvex_1_1vector.html">vex::vector&lt;double&gt;</a> Z(ctx.queue(), n);</div>
</div><!-- fragment --><p>You can now use simple vector arithmetic with device vector. For every expression you use, appropriate kernel is compiled (first time it is encountered in your program) and called automagically. If you want to see sources of the generated kernels on the standard output, define VEXCL_SHOW_KERNELS macro before including VexCL headers.</p>
<p>Vectors are processed in parallel across all devices they were allocated on: </p>
<div class="fragment"><div class="line">Y = 42;</div>
<div class="line">Z = sqrt(2 * X) + cos(Y);</div>
</div><!-- fragment --><p>You can copy the result back to host or you can use vector::operator[] to read (or write) vector elements directly. Though latter technique is very ineffective and should be used for debugging purposes only. </p>
<div class="fragment"><div class="line"><a class="code" href="namespacevex.html#a7896b8bc121f843d62d724a98ebe3b46" title="Copy device vector to host vector.">copy</a>(Z, x);</div>
<div class="line">assert(x[42] == Z[42]);</div>
</div><!-- fragment --><p>Another frequently performed operation is reduction of a vector expression to single value, such as summation. This can be done with <a class="el" href="classvex_1_1Reductor.html" title="Parallel reduction of arbitrary expression.">vex::Reductor</a> class: </p>
<div class="fragment"><div class="line">Reductor&lt;double&gt; sum(ctx.queue());</div>
<div class="line"></div>
<div class="line">std::cout &lt;&lt; sum(Z) &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; sum(sqrt(2 * X) + cos(Y)) &lt;&lt; std::endl;</div>
</div><!-- fragment --><h1><a class="anchor" id="spmv"></a>
Sparse matrix-vector multiplication</h1>
<p>One of the most common operations in linear algebra is matrix-vector multiplication. Class <a class="el" href="classvex_1_1SpMat.html" title="Sparse matrix in hybrid ELL-CSR format.">vex::SpMat</a> holds representation of a sparse matrix, spanning several devices. In the example below it is used for solution of a system of linear equations with conjugate gradients method: </p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">double</span> real;</div>
<div class="line"><span class="comment">// Solve system of linear equations A u = f with conjugate gradients method.</span></div>
<div class="line"><span class="comment">// Input matrix is represented in CSR format (parameters row, col, and val).</span></div>
<div class="line"><span class="keywordtype">void</span> cg_gpu(</div>
<div class="line">        <span class="keyword">const</span> std::vector&lt;size_t&gt; &amp;row, <span class="comment">// Indices to col and val vectors.</span></div>
<div class="line">        <span class="keyword">const</span> std::vector&lt;size_t&gt; &amp;col, <span class="comment">// Column numbers of non-zero elements.</span></div>
<div class="line">        <span class="keyword">const</span> std::vector&lt;real&gt;   &amp;val, <span class="comment">// Values of non-zero elements.</span></div>
<div class="line">        <span class="keyword">const</span> std::vector&lt;real&gt;   &amp;rhs, <span class="comment">// Right-hand side.</span></div>
<div class="line">        std::vector&lt;real&gt; &amp;x            <span class="comment">// In: initial approximation; out: result.</span></div>
<div class="line">        )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Init OpenCL.</span></div>
<div class="line">    <a class="code" href="classvex_1_1Context.html" title="VexCL context holder.">vex::Context</a> ctx(Filter::Type(CL_DEVICE_TYPE_GPU));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Move data to compute devices.</span></div>
<div class="line">    <span class="keywordtype">size_t</span> n = x.size();</div>
<div class="line">    <a class="code" href="classvex_1_1SpMat.html" title="Sparse matrix in hybrid ELL-CSR format.">vex::SpMat&lt;real&gt;</a>  A(ctx.queue(), n, row.data(), col.data(), val.data());</div>
<div class="line">    <a class="code" href="classvex_1_1vector.html">vex::vector&lt;real&gt;</a> f(ctx.queue(), rhs);</div>
<div class="line">    <a class="code" href="classvex_1_1vector.html">vex::vector&lt;real&gt;</a> u(ctx.queue(), x);</div>
<div class="line">    <a class="code" href="classvex_1_1vector.html">vex::vector&lt;real&gt;</a> r(ctx.queue(), n);</div>
<div class="line">    <a class="code" href="classvex_1_1vector.html">vex::vector&lt;real&gt;</a> p(ctx.queue(), n);</div>
<div class="line">    <a class="code" href="classvex_1_1vector.html">vex::vector&lt;real&gt;</a> q(ctx.queue(), n);</div>
<div class="line"></div>
<div class="line">    Reductor&lt;real,MAX&gt; max(ctx.queue());</div>
<div class="line">    Reductor&lt;real,SUM&gt; sum(ctx.queue());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Solve equation Au = f with conjugate gradients method.</span></div>
<div class="line">    real rho1, rho2;</div>
<div class="line">    r = f - A * u;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(uint iter = 0; max(fabs(r)) &gt; 1e-8 &amp;&amp; iter &lt; n; iter++) {</div>
<div class="line">        rho1 = sum(r * r);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (iter == 0) {</div>
<div class="line">            p = r;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            real beta = rho1 / rho2;</div>
<div class="line">            p = r + beta * p;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        q = A * p;</div>
<div class="line"></div>
<div class="line">        real alpha = rho1 / sum(p * q);</div>
<div class="line"></div>
<div class="line">        u += alpha * p;</div>
<div class="line">        r -= alpha * q;</div>
<div class="line"></div>
<div class="line">        rho2 = rho1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get result to host.</span></div>
<div class="line">    <a class="code" href="namespacevex.html#a7896b8bc121f843d62d724a98ebe3b46" title="Copy device vector to host vector.">copy</a>(u, x);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="userfun"></a>
User-defined functions</h1>
<p>Simple arithmetic expressions are sometimes not enough. Imagine that you need to count how many elements in vector x are greater that their counterparts in vector y. This may be achieved by introduction of custom function. In order to build such a function, you need to supply its body, its return type and types of its arguments. After that, you can apply the function to any valid vector expressions: </p>
<div class="fragment"><div class="line"><span class="comment">// Function body has to be defined at global scope, and it has to be of `extern</span></div>
<div class="line"><span class="comment">// const char[]` type. This allows us to use it as a template parameter.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">char</span> one_greater_than_other[] = <span class="stringliteral">&quot;return prm1 &gt; prm2 ? 1 : 0;&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">size_t</span> count_if_greater(<span class="keyword">const</span> vex:vector&lt;float&gt; &amp;x, <span class="keyword">const</span> <a class="code" href="classvex_1_1vector.html">vex::vector&lt;float&gt;</a> &amp;y) {</div>
<div class="line">    UserFunction&lt;one_greater_than_other, size_t(float, float)&gt; greater;</div>
<div class="line">    Reductor&lt;size_t, SUM&gt; sum(x.queue_list());</div>
<div class="line">    <span class="keywordflow">return</span> sum(greater(x, y));</div>
<div class="line">}</div>
</div><!-- fragment --><p>You could also write sum(greater(x + y, 5 * y)), or use any other expressions as parameters to the greater() call. Note that in the function body parameters are always named as prm1, prm2, etc.</p>
<h1><a class="anchor" id="multivector"></a>
Multi-component vectors</h1>
<p>Class template vex::multivector&lt;T,N&gt; allows to store several equally sized device vectors and perform computations on all components synchronously. Operations are delegated to the underlying vectors. Expressions may include std::array&lt;T,N&gt; values, where N is equal to the number of multivector components. Each component gets corresponding element of std::array&lt;&gt; when expression is applied. </p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> n = 1 &lt;&lt; 20;</div>
<div class="line">std::vector&lt;double&gt; host(n * 3);</div>
<div class="line">std::generate(host.begin(), host.end(), rand);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvex_1_1multivector.html">vex::multivector&lt;double,3&gt;</a> x(ctx.queue(), host);</div>
<div class="line"><a class="code" href="classvex_1_1multivector.html">vex::multivector&lt;double,3&gt;</a> y(ctx.queue(), n);</div>
<div class="line"></div>
<div class="line">std::array&lt;int, 3&gt; c = {4, 5, 6};</div>
<div class="line"></div>
<div class="line">y = 2 * cos(x) - c;</div>
<div class="line"></div>
<div class="line">std::array&lt;double,3&gt; v = y[42];</div>
<div class="line">assert(fabs(v[1] - (2 * cos(host[n + 42]) - c[1])) &lt; 1e-8);</div>
</div><!-- fragment --><p>Components of a multivector may be accessed with operator(): </p>
<div class="fragment"><div class="line"><a class="code" href="classvex_1_1vector.html">vex::vector&lt;double&gt;</a> z = y(1);</div>
</div><!-- fragment --><h1><a class="anchor" id="custkern"></a>
Using custom kernels</h1>
<p>Custom kernels are of course possible as well. vector::operator(uint) returns cl::Buffer object for a specified device: </p>
<div class="fragment"><div class="line"><a class="code" href="classvex_1_1Context.html" title="VexCL context holder.">vex::Context</a> ctx(Filter::Type(CL_DEVICE_TYPE_GPU));</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> n = 1 &lt;&lt; 20;</div>
<div class="line"><a class="code" href="classvex_1_1vector.html">vex::vector&lt;float&gt;</a> x(ctx.queue(), n);</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> program = <a class="code" href="namespacevex.html#a61989abf337d9845cad96ce9e805fd56" title="Create and build a program from source string.">build_sources</a>(context, std::string(</div>
<div class="line">    <span class="stringliteral">&quot;kernel void dummy(ulong size, global float *x)\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;{\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;    size_t i = get_global_id(0);\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;    if (i &lt; size) x[i] = 4.2;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;}\n&quot;</span></div>
<div class="line">    ));</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(uint d = 0; d &lt; ctx.size(); d++) {</div>
<div class="line">    <span class="keyword">auto</span> dummy = cl::Kernel(program, <span class="stringliteral">&quot;dummy&quot;</span>).bind(ctx.queue()[d], <a class="code" href="namespacevex.html#adde6e399118c4e9c8fdb111d23d65698" title="Align n to the next multiple of m.">alignup</a>(n, 256), 256);</div>
<div class="line">    dummy((cl_ulong)x.part_size(d), x(d));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">Reductor&lt;float,SUM&gt; sum(ctx.queue());</div>
<div class="line">std::cout &lt;&lt; sum(x) &lt;&lt; std::endl;</div>
</div><!-- fragment --><h1><a class="anchor" id="scalability"></a>
Scalability</h1>
<p>In the images below, scalability of the library with respect to number of compute devices is shown. Effective performance (GFLOPS) and bandwidth (GB/sec) were measured by launching big number of test kernels on one, two, or three Nvidia Tesla C2070 cards. The results shown are averaged over 20 runs.</p>
<p>The details of the experiments may be found in <a href="https://github.com/ddemidov/vexcl/blob/master/examples/benchmark.cpp">examples/benchmark.cpp</a> file. Basically, performance of the following code was measured:</p>
<div class="fragment"><div class="line"><span class="comment">// Vector arithmetic</span></div>
<div class="line">a += b + c * d;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Reduction</span></div>
<div class="line"><span class="keywordtype">double</span> s = sum(a * b);</div>
<div class="line"></div>
<div class="line"><span class="comment">// SpMV</span></div>
<div class="line">y += A * x;</div>
</div><!-- fragment --><div class="image">
<img src="perf.png" alt="perf.png"/>
</div>
 <h1><a class="anchor" id="compilers"></a>
Supported compilers</h1>
<p>VexCL makes heavy use of C++11 features, so your compiler has to be modern enough. GCC version 4.6 and above is fully supported. Microsoft Visual C++ 2010 manages to compile the project with some features disabled: since it does not support variadic templates, only one-argument builtin functions are enabled; user functions are not available at all. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1
</small></address>
</body>
</html>
