<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>vexcl: vex::vector&lt; T &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">vexcl
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacevex.html">vex</a>      </li>
      <li class="navelem"><a class="el" href="classvex_1_1vector.html">vector</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">vex::vector&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Device vector.  
 <a href="classvex_1_1vector.html#details">More...</a></p>

<p><code>#include &lt;vector.hpp&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for vex::vector&lt; T &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classvex_1_1vector__inherit__graph.png" border="0" usemap="#vex_1_1vector_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="vex_1_1vector_3_01T_01_4_inherit__map" id="vex_1_1vector_3_01T_01_4_inherit__map">
<area shape="rect" id="node2" href="structvex_1_1expression.html" title="Base class for a member of an expression." alt="" coords="9,6,137,34"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for vex::vector&lt; T &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classvex_1_1vector__coll__graph.png" border="0" usemap="#vex_1_1vector_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="vex_1_1vector_3_01T_01_4_coll__map" id="vex_1_1vector_3_01T_01_4_coll__map">
<area shape="rect" id="node2" href="structvex_1_1expression.html" title="Base class for a member of an expression." alt="" coords="9,6,137,34"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classvex_1_1vector-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector_1_1element.html">element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy class.  <a href="classvex_1_1vector_1_1element.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector_1_1iterator__type.html">iterator_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator class.  <a href="classvex_1_1vector_1_1iterator__type.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1de9946fa464d4bb6b7a7b930339e29a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1de9946fa464d4bb6b7a7b930339e29a"></a>
typedef <a class="el" href="classvex_1_1vector_1_1iterator__type.html">iterator_type</a>&lt; <a class="el" href="classvex_1_1vector.html">vector</a>, <br class="typebreak"/>
<a class="el" href="classvex_1_1vector_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="memitem:afd1bd847b9b29c84dbf26c8e8ce54f54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd1bd847b9b29c84dbf26c8e8ce54f54"></a>
typedef <a class="el" href="classvex_1_1vector_1_1iterator__type.html">iterator_type</a>&lt; const <br class="typebreak"/>
<a class="el" href="classvex_1_1vector.html">vector</a>, const <a class="el" href="classvex_1_1vector_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a145842a554253e273ce5ee5f3e1d602b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a145842a554253e273ce5ee5f3e1d602b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a145842a554253e273ce5ee5f3e1d602b">vector</a> ()</td></tr>
<tr class="memdesc:a145842a554253e273ce5ee5f3e1d602b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor. <br/></td></tr>
<tr class="memitem:ab0ccdbda7bf4c53459e93f3cfbcf6f01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0ccdbda7bf4c53459e93f3cfbcf6f01"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#ab0ccdbda7bf4c53459e93f3cfbcf6f01">vector</a> (const std::vector&lt; cl::CommandQueue &gt; &amp;queue, uint <a class="el" href="classvex_1_1vector.html#a075fa4ed7dc7378610b3c1e641ce9c38">size</a>, const T *host=0, cl_mem_flags flags=CL_MEM_READ_WRITE)</td></tr>
<tr class="memdesc:ab0ccdbda7bf4c53459e93f3cfbcf6f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy host data to the new buffer. <br/></td></tr>
<tr class="memitem:a6507c5202d017b3d447b9c2e59947c30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6507c5202d017b3d447b9c2e59947c30"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a6507c5202d017b3d447b9c2e59947c30">vector</a> (const std::vector&lt; cl::CommandQueue &gt; &amp;queue, const std::vector&lt; T &gt; &amp;host, cl_mem_flags flags=CL_MEM_READ_WRITE)</td></tr>
<tr class="memdesc:a6507c5202d017b3d447b9c2e59947c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy host data to the new buffer. <br/></td></tr>
<tr class="memitem:afc6a5b15bb581e5971efa2e9a3518f2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc6a5b15bb581e5971efa2e9a3518f2f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#afc6a5b15bb581e5971efa2e9a3518f2f">vector</a> (<a class="el" href="classvex_1_1vector.html">vector</a> &amp;&amp;v)</td></tr>
<tr class="memdesc:afc6a5b15bb581e5971efa2e9a3518f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br/></td></tr>
<tr class="memitem:ae757eeb5f492253973c42621ce82c503"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae757eeb5f492253973c42621ce82c503"></a>
const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#ae757eeb5f492253973c42621ce82c503">operator=</a> (<a class="el" href="classvex_1_1vector.html">vector</a> &amp;&amp;v)</td></tr>
<tr class="memdesc:ae757eeb5f492253973c42621ce82c503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment. <br/></td></tr>
<tr class="memitem:afe792e9bcb2d6efa1af5e9bd60ca0526"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe792e9bcb2d6efa1af5e9bd60ca0526"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#afe792e9bcb2d6efa1af5e9bd60ca0526">swap</a> (<a class="el" href="classvex_1_1vector.html">vector</a> &amp;v)</td></tr>
<tr class="memdesc:afe792e9bcb2d6efa1af5e9bd60ca0526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap function. <br/></td></tr>
<tr class="memitem:ab86b51939875b8e84698ddf6558a23d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab86b51939875b8e84698ddf6558a23d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#ab86b51939875b8e84698ddf6558a23d1">resize</a> (const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;v, cl_mem_flags flags=CL_MEM_READ_WRITE)</td></tr>
<tr class="memdesc:ab86b51939875b8e84698ddf6558a23d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize vector. <br/></td></tr>
<tr class="memitem:a64da7c7f029f7d0f2cb54604dc657869"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64da7c7f029f7d0f2cb54604dc657869"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a64da7c7f029f7d0f2cb54604dc657869">resize</a> (const std::vector&lt; cl::CommandQueue &gt; &amp;queue, uint <a class="el" href="classvex_1_1vector.html#a075fa4ed7dc7378610b3c1e641ce9c38">size</a>, const T *host=0, cl_mem_flags flags=CL_MEM_READ_WRITE)</td></tr>
<tr class="memdesc:a64da7c7f029f7d0f2cb54604dc657869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize vector. <br/></td></tr>
<tr class="memitem:a89ce2d148fb858750de01226b26888a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89ce2d148fb858750de01226b26888a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a89ce2d148fb858750de01226b26888a8">resize</a> (const std::vector&lt; cl::CommandQueue &gt; &amp;queue, const std::vector&lt; T &gt; &amp;host, cl_mem_flags flags=CL_MEM_READ_WRITE)</td></tr>
<tr class="memdesc:a89ce2d148fb858750de01226b26888a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize vector. <br/></td></tr>
<tr class="memitem:a26aee534bad16ac246d8d1b704f3251e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26aee534bad16ac246d8d1b704f3251e"></a>
cl::Buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a26aee534bad16ac246d8d1b704f3251e">operator()</a> (uint d=0) const </td></tr>
<tr class="memdesc:a26aee534bad16ac246d8d1b704f3251e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return cl::Buffer object located on a given device. <br/></td></tr>
<tr class="memitem:ad15856f00b1c4b80726e6f908260ef57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad15856f00b1c4b80726e6f908260ef57"></a>
<a class="el" href="classvex_1_1vector_1_1iterator__type.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#ad15856f00b1c4b80726e6f908260ef57">begin</a> () const </td></tr>
<tr class="memdesc:ad15856f00b1c4b80726e6f908260ef57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator to beginning. <br/></td></tr>
<tr class="memitem:a5169d2645c884403fa690d45c77552fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5169d2645c884403fa690d45c77552fa"></a>
<a class="el" href="classvex_1_1vector_1_1iterator__type.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a5169d2645c884403fa690d45c77552fa">end</a> () const </td></tr>
<tr class="memdesc:a5169d2645c884403fa690d45c77552fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator to end. <br/></td></tr>
<tr class="memitem:acd24b2e97a30866d8c7ec073bd18abcc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd24b2e97a30866d8c7ec073bd18abcc"></a>
<a class="el" href="classvex_1_1vector_1_1iterator__type.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#acd24b2e97a30866d8c7ec073bd18abcc">begin</a> ()</td></tr>
<tr class="memdesc:acd24b2e97a30866d8c7ec073bd18abcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to beginning. <br/></td></tr>
<tr class="memitem:a60c895b0b0f6540d3d7a4a9c05aeb7cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60c895b0b0f6540d3d7a4a9c05aeb7cb"></a>
<a class="el" href="classvex_1_1vector_1_1iterator__type.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a60c895b0b0f6540d3d7a4a9c05aeb7cb">end</a> ()</td></tr>
<tr class="memdesc:a60c895b0b0f6540d3d7a4a9c05aeb7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to end. <br/></td></tr>
<tr class="memitem:aff94d77573bb545cf64c52ebd702ee59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff94d77573bb545cf64c52ebd702ee59"></a>
const <a class="el" href="classvex_1_1vector_1_1element.html">element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#aff94d77573bb545cf64c52ebd702ee59">operator[]</a> (uint index) const </td></tr>
<tr class="memdesc:aff94d77573bb545cf64c52ebd702ee59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element. <br/></td></tr>
<tr class="memitem:a5a81ff31e62d8881194de32f2f89a478"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a81ff31e62d8881194de32f2f89a478"></a>
<a class="el" href="classvex_1_1vector_1_1element.html">element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a5a81ff31e62d8881194de32f2f89a478">operator[]</a> (uint index)</td></tr>
<tr class="memdesc:a5a81ff31e62d8881194de32f2f89a478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element. <br/></td></tr>
<tr class="memitem:a075fa4ed7dc7378610b3c1e641ce9c38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a075fa4ed7dc7378610b3c1e641ce9c38"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a075fa4ed7dc7378610b3c1e641ce9c38">size</a> () const </td></tr>
<tr class="memdesc:a075fa4ed7dc7378610b3c1e641ce9c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size . <br/></td></tr>
<tr class="memitem:a76d1d5e65c2beda12dfb0c4a2ea40c49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76d1d5e65c2beda12dfb0c4a2ea40c49"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a76d1d5e65c2beda12dfb0c4a2ea40c49">nparts</a> () const </td></tr>
<tr class="memdesc:a76d1d5e65c2beda12dfb0c4a2ea40c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of parts (devices). <br/></td></tr>
<tr class="memitem:ad26162c42f9dc2f9df160bfde4acab4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad26162c42f9dc2f9df160bfde4acab4c"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#ad26162c42f9dc2f9df160bfde4acab4c">part_size</a> (uint d) const </td></tr>
<tr class="memdesc:ad26162c42f9dc2f9df160bfde4acab4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size of part on a given device. <br/></td></tr>
<tr class="memitem:adedf824ab0681d4bc7e230c716a77c40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adedf824ab0681d4bc7e230c716a77c40"></a>
const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#adedf824ab0681d4bc7e230c716a77c40">operator=</a> (const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;x)</td></tr>
<tr class="memdesc:adedf824ab0681d4bc7e230c716a77c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from device vector. <br/></td></tr>
<tr class="memitem:a9d1e98a0846c1592b5d68ce0c110b831"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d1e98a0846c1592b5d68ce0c110b831"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a9d1e98a0846c1592b5d68ce0c110b831">write_data</a> (uint offset, uint <a class="el" href="classvex_1_1vector.html#a075fa4ed7dc7378610b3c1e641ce9c38">size</a>, const T *hostptr, cl_bool blocking)</td></tr>
<tr class="memdesc:a9d1e98a0846c1592b5d68ce0c110b831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from host buffer to device(s). <br/></td></tr>
<tr class="memitem:ae76a09165dbb324de64688e6dc8262b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae76a09165dbb324de64688e6dc8262b3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#ae76a09165dbb324de64688e6dc8262b3">read_data</a> (uint offset, uint <a class="el" href="classvex_1_1vector.html#a075fa4ed7dc7378610b3c1e641ce9c38">size</a>, T *hostptr, cl_bool blocking) const </td></tr>
<tr class="memdesc:ae76a09165dbb324de64688e6dc8262b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from device(s) to host buffer . <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Expression assignments.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The appropriate kernel is compiled first time the assignment is made. Vectors participating in expression should have same number of parts; corresponding parts of the vectors should reside on the same compute devices. </p>
</div></td></tr>
<tr class="memitem:adf3307f913b582c50f9962930f0088c7"><td class="memTemplParams" colspan="2"><a class="anchor" id="adf3307f913b582c50f9962930f0088c7"></a>
template&lt;class Expr &gt; </td></tr>
<tr class="memitem:adf3307f913b582c50f9962930f0088c7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const Expr &amp;expr)</td></tr>
<tr class="memitem:abde5fd2b20412cc73bde08f33c83fb2f"><td class="memTemplParams" colspan="2"><a class="anchor" id="abde5fd2b20412cc73bde08f33c83fb2f"></a>
template&lt;class Expr &gt; </td></tr>
<tr class="memitem:abde5fd2b20412cc73bde08f33c83fb2f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const Expr &amp;expr)</td></tr>
<tr class="memitem:aadbae2ada65e7ba984ea217b36ab9670"><td class="memTemplParams" colspan="2"><a class="anchor" id="aadbae2ada65e7ba984ea217b36ab9670"></a>
template&lt;class Expr &gt; </td></tr>
<tr class="memitem:aadbae2ada65e7ba984ea217b36ab9670"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const Expr &amp;expr)</td></tr>
<tr class="memitem:a51076907d763c0917e12c880ce575536"><td class="memTemplParams" colspan="2"><a class="anchor" id="a51076907d763c0917e12c880ce575536"></a>
template&lt;class Expr &gt; </td></tr>
<tr class="memitem:a51076907d763c0917e12c880ce575536"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (const Expr &amp;expr)</td></tr>
<tr class="memitem:abc692cd6e6c89c352f0e3dd87fbed427"><td class="memTemplParams" colspan="2"><a class="anchor" id="abc692cd6e6c89c352f0e3dd87fbed427"></a>
template&lt;class Expr &gt; </td></tr>
<tr class="memitem:abc692cd6e6c89c352f0e3dd87fbed427"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const Expr &amp;expr)</td></tr>
<tr class="memitem:aa7e1fd01862df629bb70d8aad03502fa"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa7e1fd01862df629bb70d8aad03502fa"></a>
template&lt;class Expr &gt; </td></tr>
<tr class="memitem:aa7e1fd01862df629bb70d8aad03502fa"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const ExSpMV&lt; Expr, T &gt; &amp;xmv)</td></tr>
<tr class="memitem:af6604b82fb2de7c3e4786f41916ae179"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6604b82fb2de7c3e4786f41916ae179"></a>
const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const SpMV&lt; T &gt; &amp;spmv)</td></tr>
<tr class="memitem:a7dd17f7eab2073c35a8ca9a3cc894ab3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dd17f7eab2073c35a8ca9a3cc894ab3"></a>
const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const SpMV&lt; T &gt; &amp;spmv)</td></tr>
<tr class="memitem:a120017f9bffb1045260177a56d868893"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a120017f9bffb1045260177a56d868893"></a>
const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const SpMV&lt; T &gt; &amp;spmv)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Service methods used for kernel generation.</div></td></tr>
<tr class="memitem:ab6eed97fe105cc43a54d9f954e56c11f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#ab6eed97fe105cc43a54d9f954e56c11f">kernel_name</a> () const </td></tr>
<tr class="memdesc:ab6eed97fe105cc43a54d9f954e56c11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel name.  <a href="#ab6eed97fe105cc43a54d9f954e56c11f"></a><br/></td></tr>
<tr class="memitem:a6fabc794a73441c1abd5a611877e9bf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a6fabc794a73441c1abd5a611877e9bf4">kernel_expr</a> (std::ostream &amp;os, std::string name) const </td></tr>
<tr class="memdesc:a6fabc794a73441c1abd5a611877e9bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel body.  <a href="#a6fabc794a73441c1abd5a611877e9bf4"></a><br/></td></tr>
<tr class="memitem:a7f35266a8b9d677050a2409cd846c60f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a7f35266a8b9d677050a2409cd846c60f">kernel_prm</a> (std::ostream &amp;os, std::string name) const </td></tr>
<tr class="memdesc:a7f35266a8b9d677050a2409cd846c60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel parameter list.  <a href="#a7f35266a8b9d677050a2409cd846c60f"></a><br/></td></tr>
<tr class="memitem:ac66f80a18afbd2fd380d93c130e244dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#ac66f80a18afbd2fd380d93c130e244dd">kernel_args</a> (cl::Kernel &amp;k, uint devnum, uint &amp;pos) const </td></tr>
<tr class="memdesc:ac66f80a18afbd2fd380d93c130e244dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel arguments.  <a href="#ac66f80a18afbd2fd380d93c130e244dd"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br/>
class vex::vector&lt; T &gt;</h3>

<p>Device vector. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac66f80a18afbd2fd380d93c130e244dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt;::<a class="el" href="classvex_1_1vector.html#ac66f80a18afbd2fd380d93c130e244dd">kernel_args</a> </td>
          <td>(</td>
          <td class="paramtype">cl::Kernel &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>devnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Kernel arguments. </p>
<p>This function is called at the time of actual kernel launch. Each terminal expression should set kernel arguments for the parameters it needs at specified position. Position should be incremented afterwards. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>OpenCL kernel that is being prepared to launch. </td></tr>
    <tr><td class="paramname">devnum</td><td>Number of queue in queue list for which the kernel is launched. </td></tr>
    <tr><td class="paramname">pos</td><td>Current position in parameter stack. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="structvex_1_1expression.html#a6b24e8d28bd01c9fa1251d29914c448b">vex::expression</a>.</p>

</div>
</div>
<a class="anchor" id="a6fabc794a73441c1abd5a611877e9bf4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt;::<a class="el" href="classvex_1_1vector.html#a6fabc794a73441c1abd5a611877e9bf4">kernel_expr</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Kernel body. </p>
<p>The actual expression which forms the kernel body. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream which holds kernel source. </td></tr>
    <tr><td class="paramname">name</td><td>Name of current node in an expression tree. Should be used directly or as a prefix to form parameter name(s). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="structvex_1_1expression.html#a5e61c6e9c042b05f752a735524f513f7">vex::expression</a>.</p>

</div>
</div>
<a class="anchor" id="ab6eed97fe105cc43a54d9f954e56c11f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt;::<a class="el" href="classvex_1_1vector.html#ab6eed97fe105cc43a54d9f954e56c11f">kernel_name</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Kernel name. </p>
<p>Name of the kernel is formed by its members through calls to their <a class="el" href="classvex_1_1vector.html#ab6eed97fe105cc43a54d9f954e56c11f" title="Kernel name.">kernel_name()</a> functions. For example, expression </p>
<div class="fragment"><pre class="fragment">   x = 3 * y + z;
</pre></div><p> will result in kernel named "ptcvv" (plus times constant vector vector; polish notation is used). This naming scheme is not strictly necessary, as each expression template holds its own cl::Program object and no ambiguity is possible. But it helps when you profiling your program performance. </p>

<p>Implements <a class="el" href="structvex_1_1expression.html#a484ab189ffcc72aac844dd3930ca1a1c">vex::expression</a>.</p>

</div>
</div>
<a class="anchor" id="a7f35266a8b9d677050a2409cd846c60f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt;::<a class="el" href="classvex_1_1vector.html#a7f35266a8b9d677050a2409cd846c60f">kernel_prm</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Kernel parameter list. </p>
<p>Each terminal expression should output type and name of kernel parameters it needs here. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream which holds kernel source. </td></tr>
    <tr><td class="paramname">name</td><td>Name of current node in an expression tree. Should be used directly or as a prefix to form parameter name(s). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="structvex_1_1expression.html#a667249405062a73ac52cfaa0614243f5">vex::expression</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="vector_8hpp.html">vector.hpp</a></li>
<li><a class="el" href="spmat_8hpp.html">spmat.hpp</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
