<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>vexcl: vex::vector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vexcl
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevex.html">vex</a></li><li class="navelem"><a class="el" href="classvex_1_1vector.html">vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">vex::vector&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Device vector.  
 <a href="classvex_1_1vector.html#details">More...</a></p>

<p><code>#include &lt;vector.hpp&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for vex::vector&lt; T &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classvex_1_1vector__inherit__graph.png" border="0" usemap="#vex_1_1vector_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="vex_1_1vector_3_01T_01_4_inherit__map" id="vex_1_1vector_3_01T_01_4_inherit__map">
<area shape="rect" id="node2" href="structvex_1_1expression.html" title="Base class for a member of an expression." alt="" coords="9,6,137,34"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for vex::vector&lt; T &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classvex_1_1vector__coll__graph.png" border="0" usemap="#vex_1_1vector_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="vex_1_1vector_3_01T_01_4_coll__map" id="vex_1_1vector_3_01T_01_4_coll__map">
<area shape="rect" id="node2" href="structvex_1_1expression.html" title="Base class for a member of an expression." alt="" coords="9,6,137,34"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classvex_1_1vector-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector_1_1element.html">element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy class.  <a href="classvex_1_1vector_1_1element.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector_1_1iterator__type.html">iterator_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator class.  <a href="classvex_1_1vector_1_1iterator__type.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1de9946fa464d4bb6b7a7b930339e29a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1de9946fa464d4bb6b7a7b930339e29a"></a>
typedef <a class="el" href="classvex_1_1vector_1_1iterator__type.html">iterator_type</a>&lt; <a class="el" href="classvex_1_1vector.html">vector</a>, <br class="typebreak"/>
<a class="el" href="classvex_1_1vector_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="memitem:afd1bd847b9b29c84dbf26c8e8ce54f54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd1bd847b9b29c84dbf26c8e8ce54f54"></a>
typedef <a class="el" href="classvex_1_1vector_1_1iterator__type.html">iterator_type</a>&lt; const <br class="typebreak"/>
<a class="el" href="classvex_1_1vector.html">vector</a>, const <a class="el" href="classvex_1_1vector_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a145842a554253e273ce5ee5f3e1d602b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a145842a554253e273ce5ee5f3e1d602b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a145842a554253e273ce5ee5f3e1d602b">vector</a> ()</td></tr>
<tr class="memdesc:a145842a554253e273ce5ee5f3e1d602b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor. <br/></td></tr>
<tr class="memitem:add76a9d6bb57a8a25821ba8f6349c026"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add76a9d6bb57a8a25821ba8f6349c026"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#add76a9d6bb57a8a25821ba8f6349c026">vector</a> (const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;v)</td></tr>
<tr class="memdesc:add76a9d6bb57a8a25821ba8f6349c026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr class="memitem:aae780f1365bb3becf25b049d25ed9622"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae780f1365bb3becf25b049d25ed9622"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#aae780f1365bb3becf25b049d25ed9622">vector</a> (const std::vector&lt; cl::CommandQueue &gt; &amp;queue, size_t <a class="el" href="classvex_1_1vector.html#acba96d67dcc97afdc6ff552d913ca7d7">size</a>, const T *host=0, cl_mem_flags flags=CL_MEM_READ_WRITE)</td></tr>
<tr class="memdesc:aae780f1365bb3becf25b049d25ed9622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy host data to the new buffer. <br/></td></tr>
<tr class="memitem:a6507c5202d017b3d447b9c2e59947c30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6507c5202d017b3d447b9c2e59947c30"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a6507c5202d017b3d447b9c2e59947c30">vector</a> (const std::vector&lt; cl::CommandQueue &gt; &amp;queue, const std::vector&lt; T &gt; &amp;host, cl_mem_flags flags=CL_MEM_READ_WRITE)</td></tr>
<tr class="memdesc:a6507c5202d017b3d447b9c2e59947c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy host data to the new buffer. <br/></td></tr>
<tr class="memitem:afc6a5b15bb581e5971efa2e9a3518f2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc6a5b15bb581e5971efa2e9a3518f2f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#afc6a5b15bb581e5971efa2e9a3518f2f">vector</a> (<a class="el" href="classvex_1_1vector.html">vector</a> &amp;&amp;v)</td></tr>
<tr class="memdesc:afc6a5b15bb581e5971efa2e9a3518f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br/></td></tr>
<tr class="memitem:ae757eeb5f492253973c42621ce82c503"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae757eeb5f492253973c42621ce82c503"></a>
const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#ae757eeb5f492253973c42621ce82c503">operator=</a> (<a class="el" href="classvex_1_1vector.html">vector</a> &amp;&amp;v)</td></tr>
<tr class="memdesc:ae757eeb5f492253973c42621ce82c503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment. <br/></td></tr>
<tr class="memitem:afe792e9bcb2d6efa1af5e9bd60ca0526"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe792e9bcb2d6efa1af5e9bd60ca0526"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#afe792e9bcb2d6efa1af5e9bd60ca0526">swap</a> (<a class="el" href="classvex_1_1vector.html">vector</a> &amp;v)</td></tr>
<tr class="memdesc:afe792e9bcb2d6efa1af5e9bd60ca0526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap function. <br/></td></tr>
<tr class="memitem:ab86b51939875b8e84698ddf6558a23d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab86b51939875b8e84698ddf6558a23d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#ab86b51939875b8e84698ddf6558a23d1">resize</a> (const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;v, cl_mem_flags flags=CL_MEM_READ_WRITE)</td></tr>
<tr class="memdesc:ab86b51939875b8e84698ddf6558a23d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize vector. <br/></td></tr>
<tr class="memitem:a90c1fa2468fd173040fd433d68d9b76a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90c1fa2468fd173040fd433d68d9b76a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a90c1fa2468fd173040fd433d68d9b76a">resize</a> (const std::vector&lt; cl::CommandQueue &gt; &amp;queue, size_t <a class="el" href="classvex_1_1vector.html#acba96d67dcc97afdc6ff552d913ca7d7">size</a>, const T *host=0, cl_mem_flags flags=CL_MEM_READ_WRITE)</td></tr>
<tr class="memdesc:a90c1fa2468fd173040fd433d68d9b76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize vector. <br/></td></tr>
<tr class="memitem:a89ce2d148fb858750de01226b26888a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89ce2d148fb858750de01226b26888a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a89ce2d148fb858750de01226b26888a8">resize</a> (const std::vector&lt; cl::CommandQueue &gt; &amp;queue, const std::vector&lt; T &gt; &amp;host, cl_mem_flags flags=CL_MEM_READ_WRITE)</td></tr>
<tr class="memdesc:a89ce2d148fb858750de01226b26888a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize vector. <br/></td></tr>
<tr class="memitem:a26aee534bad16ac246d8d1b704f3251e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26aee534bad16ac246d8d1b704f3251e"></a>
cl::Buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a26aee534bad16ac246d8d1b704f3251e">operator()</a> (uint d=0) const </td></tr>
<tr class="memdesc:a26aee534bad16ac246d8d1b704f3251e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return cl::Buffer object located on a given device. <br/></td></tr>
<tr class="memitem:ad15856f00b1c4b80726e6f908260ef57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad15856f00b1c4b80726e6f908260ef57"></a>
<a class="el" href="classvex_1_1vector_1_1iterator__type.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#ad15856f00b1c4b80726e6f908260ef57">begin</a> () const </td></tr>
<tr class="memdesc:ad15856f00b1c4b80726e6f908260ef57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator to beginning. <br/></td></tr>
<tr class="memitem:a5169d2645c884403fa690d45c77552fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5169d2645c884403fa690d45c77552fa"></a>
<a class="el" href="classvex_1_1vector_1_1iterator__type.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a5169d2645c884403fa690d45c77552fa">end</a> () const </td></tr>
<tr class="memdesc:a5169d2645c884403fa690d45c77552fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator to end. <br/></td></tr>
<tr class="memitem:acd24b2e97a30866d8c7ec073bd18abcc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd24b2e97a30866d8c7ec073bd18abcc"></a>
<a class="el" href="classvex_1_1vector_1_1iterator__type.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#acd24b2e97a30866d8c7ec073bd18abcc">begin</a> ()</td></tr>
<tr class="memdesc:acd24b2e97a30866d8c7ec073bd18abcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to beginning. <br/></td></tr>
<tr class="memitem:a60c895b0b0f6540d3d7a4a9c05aeb7cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60c895b0b0f6540d3d7a4a9c05aeb7cb"></a>
<a class="el" href="classvex_1_1vector_1_1iterator__type.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a60c895b0b0f6540d3d7a4a9c05aeb7cb">end</a> ()</td></tr>
<tr class="memdesc:a60c895b0b0f6540d3d7a4a9c05aeb7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to end. <br/></td></tr>
<tr class="memitem:a88c42ebe2e8c3001e1210dfb66f0da6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88c42ebe2e8c3001e1210dfb66f0da6a"></a>
const <a class="el" href="classvex_1_1vector_1_1element.html">element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a88c42ebe2e8c3001e1210dfb66f0da6a">operator[]</a> (size_t index) const </td></tr>
<tr class="memdesc:a88c42ebe2e8c3001e1210dfb66f0da6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element. <br/></td></tr>
<tr class="memitem:a0f128e48db61d7d94748a2a29f6eb709"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f128e48db61d7d94748a2a29f6eb709"></a>
<a class="el" href="classvex_1_1vector_1_1element.html">element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a0f128e48db61d7d94748a2a29f6eb709">operator[]</a> (size_t index)</td></tr>
<tr class="memdesc:a0f128e48db61d7d94748a2a29f6eb709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element. <br/></td></tr>
<tr class="memitem:acba96d67dcc97afdc6ff552d913ca7d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acba96d67dcc97afdc6ff552d913ca7d7"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#acba96d67dcc97afdc6ff552d913ca7d7">size</a> () const </td></tr>
<tr class="memdesc:acba96d67dcc97afdc6ff552d913ca7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size . <br/></td></tr>
<tr class="memitem:a76d1d5e65c2beda12dfb0c4a2ea40c49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76d1d5e65c2beda12dfb0c4a2ea40c49"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a76d1d5e65c2beda12dfb0c4a2ea40c49">nparts</a> () const </td></tr>
<tr class="memdesc:a76d1d5e65c2beda12dfb0c4a2ea40c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of parts (devices). <br/></td></tr>
<tr class="memitem:a3404c8ef9b7b06ed88679d0247016359"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3404c8ef9b7b06ed88679d0247016359"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a3404c8ef9b7b06ed88679d0247016359">part_size</a> (uint d) const </td></tr>
<tr class="memdesc:a3404c8ef9b7b06ed88679d0247016359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size of part on a given device. <br/></td></tr>
<tr class="memitem:a64c9b104b362b5ded3af3f3e2750efe5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64c9b104b362b5ded3af3f3e2750efe5"></a>
const std::vector<br class="typebreak"/>
&lt; cl::CommandQueue &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a64c9b104b362b5ded3af3f3e2750efe5">queue_list</a> () const </td></tr>
<tr class="memdesc:a64c9b104b362b5ded3af3f3e2750efe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reference to vector's queue list. <br/></td></tr>
<tr class="memitem:adedf824ab0681d4bc7e230c716a77c40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adedf824ab0681d4bc7e230c716a77c40"></a>
const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#adedf824ab0681d4bc7e230c716a77c40">operator=</a> (const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;x)</td></tr>
<tr class="memdesc:adedf824ab0681d4bc7e230c716a77c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from device vector. <br/></td></tr>
<tr class="memitem:a79dc9f8d9b9d34698a8e9fdaec9c72f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79dc9f8d9b9d34698a8e9fdaec9c72f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a79dc9f8d9b9d34698a8e9fdaec9c72f5">write_data</a> (size_t offset, size_t <a class="el" href="classvex_1_1vector.html#acba96d67dcc97afdc6ff552d913ca7d7">size</a>, const T *hostptr, cl_bool blocking)</td></tr>
<tr class="memdesc:a79dc9f8d9b9d34698a8e9fdaec9c72f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from host buffer to device(s). <br/></td></tr>
<tr class="memitem:addecd3736da882b8a9c344a530c4843f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addecd3736da882b8a9c344a530c4843f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#addecd3736da882b8a9c344a530c4843f">read_data</a> (size_t offset, size_t <a class="el" href="classvex_1_1vector.html#acba96d67dcc97afdc6ff552d913ca7d7">size</a>, T *hostptr, cl_bool blocking) const </td></tr>
<tr class="memdesc:addecd3736da882b8a9c344a530c4843f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from device(s) to host buffer . <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Expression assignments.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The appropriate kernel is compiled first time the assignment is made. Vectors participating in expression should have same number of parts; corresponding parts of the vectors should reside on the same compute devices. </p>
</div></td></tr>
<tr class="memitem:adf3307f913b582c50f9962930f0088c7"><td class="memTemplParams" colspan="2"><a class="anchor" id="adf3307f913b582c50f9962930f0088c7"></a>
template&lt;class Expr &gt; </td></tr>
<tr class="memitem:adf3307f913b582c50f9962930f0088c7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const Expr &amp;expr)</td></tr>
<tr class="memitem:abde5fd2b20412cc73bde08f33c83fb2f"><td class="memTemplParams" colspan="2"><a class="anchor" id="abde5fd2b20412cc73bde08f33c83fb2f"></a>
template&lt;class Expr &gt; </td></tr>
<tr class="memitem:abde5fd2b20412cc73bde08f33c83fb2f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const Expr &amp;expr)</td></tr>
<tr class="memitem:aadbae2ada65e7ba984ea217b36ab9670"><td class="memTemplParams" colspan="2"><a class="anchor" id="aadbae2ada65e7ba984ea217b36ab9670"></a>
template&lt;class Expr &gt; </td></tr>
<tr class="memitem:aadbae2ada65e7ba984ea217b36ab9670"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const Expr &amp;expr)</td></tr>
<tr class="memitem:a51076907d763c0917e12c880ce575536"><td class="memTemplParams" colspan="2"><a class="anchor" id="a51076907d763c0917e12c880ce575536"></a>
template&lt;class Expr &gt; </td></tr>
<tr class="memitem:a51076907d763c0917e12c880ce575536"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (const Expr &amp;expr)</td></tr>
<tr class="memitem:abc692cd6e6c89c352f0e3dd87fbed427"><td class="memTemplParams" colspan="2"><a class="anchor" id="abc692cd6e6c89c352f0e3dd87fbed427"></a>
template&lt;class Expr &gt; </td></tr>
<tr class="memitem:abc692cd6e6c89c352f0e3dd87fbed427"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const Expr &amp;expr)</td></tr>
<tr class="memitem:a269db0bfb6b0f37757e445822643d297"><td class="memTemplParams" colspan="2"><a class="anchor" id="a269db0bfb6b0f37757e445822643d297"></a>
template&lt;class Expr , typename column_t &gt; </td></tr>
<tr class="memitem:a269db0bfb6b0f37757e445822643d297"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const ExSpMV&lt; Expr, T, column_t &gt; &amp;xmv)</td></tr>
<tr class="memitem:a2354abf9c187ee4f82ae0c2cd958f4e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2354abf9c187ee4f82ae0c2cd958f4e4"></a>
template&lt;typename column_t &gt; </td></tr>
<tr class="memitem:a2354abf9c187ee4f82ae0c2cd958f4e4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const SpMV&lt; T, column_t &gt; &amp;spmv)</td></tr>
<tr class="memitem:a8bab5385b39c931522184c7ab0bdb289"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8bab5385b39c931522184c7ab0bdb289"></a>
template&lt;typename column_t &gt; </td></tr>
<tr class="memitem:a8bab5385b39c931522184c7ab0bdb289"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const SpMV&lt; T, column_t &gt; &amp;spmv)</td></tr>
<tr class="memitem:a0edc591286e9742aaec4bc69c3da0413"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0edc591286e9742aaec4bc69c3da0413"></a>
template&lt;typename column_t &gt; </td></tr>
<tr class="memitem:a0edc591286e9742aaec4bc69c3da0413"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1vector.html">vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const SpMV&lt; T, column_t &gt; &amp;spmv)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Service methods used for kernel generation.</div></td></tr>
<tr class="memitem:ab6eed97fe105cc43a54d9f954e56c11f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#ab6eed97fe105cc43a54d9f954e56c11f">kernel_name</a> () const </td></tr>
<tr class="memdesc:ab6eed97fe105cc43a54d9f954e56c11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel name.  <a href="#ab6eed97fe105cc43a54d9f954e56c11f"></a><br/></td></tr>
<tr class="memitem:a6fabc794a73441c1abd5a611877e9bf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a6fabc794a73441c1abd5a611877e9bf4">kernel_expr</a> (std::ostream &amp;os, std::string name) const </td></tr>
<tr class="memdesc:a6fabc794a73441c1abd5a611877e9bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel body.  <a href="#a6fabc794a73441c1abd5a611877e9bf4"></a><br/></td></tr>
<tr class="memitem:a7f35266a8b9d677050a2409cd846c60f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#a7f35266a8b9d677050a2409cd846c60f">kernel_prm</a> (std::ostream &amp;os, std::string name) const </td></tr>
<tr class="memdesc:a7f35266a8b9d677050a2409cd846c60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel parameter list.  <a href="#a7f35266a8b9d677050a2409cd846c60f"></a><br/></td></tr>
<tr class="memitem:ac66f80a18afbd2fd380d93c130e244dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html#ac66f80a18afbd2fd380d93c130e244dd">kernel_args</a> (cl::Kernel &amp;k, uint devnum, uint &amp;pos) const </td></tr>
<tr class="memdesc:ac66f80a18afbd2fd380d93c130e244dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel arguments.  <a href="#ac66f80a18afbd2fd380d93c130e244dd"></a><br/></td></tr>
<tr class="inherit_header pub_methods_structvex_1_1expression"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structvex_1_1expression')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="structvex_1_1expression.html">vex::expression</a></td></tr>
<tr class="memitem:a0b054002a358e3f9f1df0a6e32f19d5b inherit pub_methods_structvex_1_1expression"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1expression.html#a0b054002a358e3f9f1df0a6e32f19d5b">preamble</a> (std::ostream &amp;os, std::string name) const </td></tr>
<tr class="memdesc:a0b054002a358e3f9f1df0a6e32f19d5b inherit pub_methods_structvex_1_1expression"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preamble.  <a href="#a0b054002a358e3f9f1df0a6e32f19d5b"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_structvex_1_1expression"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_structvex_1_1expression')"><img src="closed.png" alt="-"/>&nbsp;Static Public Attributes inherited from <a class="el" href="structvex_1_1expression.html">vex::expression</a></td></tr>
<tr class="memitem:a291d9034f2397526bf9e698f896ee682 inherit pub_static_attribs_structvex_1_1expression"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a291d9034f2397526bf9e698f896ee682"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_expression</b> = true</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br/>
class vex::vector&lt; T &gt;</h3>

<p>Device vector. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac66f80a18afbd2fd380d93c130e244dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt;::kernel_args </td>
          <td>(</td>
          <td class="paramtype">cl::Kernel &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>devnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kernel arguments. </p>
<p>This function is called at the time of actual kernel launch. Each terminal expression should set kernel arguments for the parameters it needs at specified position. Position should be incremented afterwards. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>OpenCL kernel that is being prepared to launch. </td></tr>
    <tr><td class="paramname">devnum</td><td>Number of queue in queue list for which the kernel is launched. </td></tr>
    <tr><td class="paramname">pos</td><td>Current position in parameter stack. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="structvex_1_1expression.html#a6b24e8d28bd01c9fa1251d29914c448b">vex::expression</a>.</p>

</div>
</div>
<a class="anchor" id="a6fabc794a73441c1abd5a611877e9bf4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt;::kernel_expr </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kernel body. </p>
<p>The actual expression which forms the kernel body. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream which holds kernel source. </td></tr>
    <tr><td class="paramname">name</td><td>Name of current node in an expression tree. Should be used directly or as a prefix to form parameter name(s). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="structvex_1_1expression.html#a5e61c6e9c042b05f752a735524f513f7">vex::expression</a>.</p>

</div>
</div>
<a class="anchor" id="ab6eed97fe105cc43a54d9f954e56c11f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt;::kernel_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kernel name. </p>
<p>Name of the kernel is formed by its members through calls to their <a class="el" href="classvex_1_1vector.html#ab6eed97fe105cc43a54d9f954e56c11f" title="Kernel name.">kernel_name()</a> functions. For example, expression </p>
<div class="fragment"><div class="line">   x = 3 * y + z;</div>
</div><!-- fragment --><p> will result in kernel named "ptcvv" (plus times constant vector vector; polish notation is used). This naming scheme is not strictly necessary, as each expression template holds its own cl::Program object and no ambiguity is possible. But it helps when you profiling your program performance. </p>

<p>Implements <a class="el" href="structvex_1_1expression.html#a484ab189ffcc72aac844dd3930ca1a1c">vex::expression</a>.</p>

</div>
</div>
<a class="anchor" id="a7f35266a8b9d677050a2409cd846c60f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt;::kernel_prm </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kernel parameter list. </p>
<p>Each terminal expression should output type and name of kernel parameters it needs here. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream which holds kernel source. </td></tr>
    <tr><td class="paramname">name</td><td>Name of current node in an expression tree. Should be used directly or as a prefix to form parameter name(s). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="structvex_1_1expression.html#a667249405062a73ac52cfaa0614243f5">vex::expression</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="vector_8hpp.html">vector.hpp</a></li>
<li><a class="el" href="spmat_8hpp.html">spmat.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1
</small></address>
</body>
</html>
